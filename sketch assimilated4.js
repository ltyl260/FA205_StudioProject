// taken from "camera save photo" by joshmiller
// https://editor.p5js.org/joshmiller/sketches/HyyWhllFX
// trying to find differences between screenshot and live
// ## first issue: capturing the webcam ##
// p5js version works but VSCodium only holds the upper right corner of the selection...
// > issue was in the size of the capture, draw... needed to specify display size
// > mostly in the mouse pressed function when getting the hold image through
// > hold = capture.get(0, 0,capture.width,capture.height); needs to be adjusted to capture height...

// ** now that thats fixed.. I need to find the differences between the hold image and the live capture...*
// ## second issue: traversing the capture ##
// from my test i have found that even with a pure black input the webcam values still fluctuate up to 11
// > text(str(capture.pixels[20] + ' is ' + hold.pixels[20] +' = '+ (capture.pixels[idx] != hold.pixels[idx])), 30,30);
//  so i will need to adjust my conditional brackest
// from if ((capture.pixels[idx] != hold.pixels[idx])&&(capture.pixels[idx+1] != hold.pixels[idx+1])&&(capture.pixels[idx+2] != hold.pixels[idx+2])){
// to if ((((hold.pixels[idx+0] - r) > capture.pixels[idx+0]) || (capture.pixels[idx+0] > hold.pixels[idx+0] + r))||(((hold.pixels[idx+1] - r) > capture.pixels[idx+1]) || (capture.pixels[idx+1] > hold.pixels[idx+1] + r))|| (((hold.pixels[idx+2] - r) > capture.pixels[idx+2]) || (capture.pixels[idx+2] > hold.pixels[idx+2] + r)))
// > made variable range because +- 25 ended up being a more reasonable range from my test
// ## third issue: continuous capture NOT generated by mouseclicks ##
// a wokring script for motion capture https://editor.p5js.org/bestesaylar/sketches/WFsPqG-8A by bestesaylar was helpful
// and my issue was not knowing how to store the images which has been fixed by bestesaylars working sketch
// ## fourth step: ducks! ## 
// instead of the motion showing up as red pixels id like to have ducks appear
// this requires reusing my duck class and fitting it to this purpose. Initialising a duck will only require x and y positions, i am not worrying about a duck existing for longer than movement is detected at this stage they will just appear instead of the pixels, size will be set with the scalar just like the pixels are in the example
// ### forth issue: ducks arent appearing at desire x,y points ###
// i have manually multiplied the x and y by factors of 4 - 
// looks like the loops traverse the size of the capture and not the size of the screen, multiply by scaler to fix :)
// worked it out! since we divide our image by a scaler and we are only traversing this reduced image then we only get the x and y points of this reduced image, by multiplying by the scaler we remove this issue!
// ### could be nice: to make the window more adaptable ###
// https://www.youtube.com/watch?v=a_6ggdvsIYE also had some ideas spefically abut fititng the window height and width! look into this for adaptability... mobile etc...
// however its not immediately working so I will leave that for another project as its not essential to my ideal resolution.

// ### fifth issue: longevity of ducks ###
// If I want the movements of the viewer to make traces from their movement ill need to remember where the movement has been...
// I created new arrays and variables
// >let xmoved = []; to store x position of points that have moved
// >let ymoved = []; to store y position of points that have moved
// >let compx; to store x position of points that have moved
// >let compy; to store y position of points that have moved
// this was taking forever to load...
// I added another variable and array with the hopes of only saving THE most moved point and then 'tracing' that. 
// >let diffmoved = []; to store total diff of points that have moved
// >let compdiff; to store total of the greatest diff that has moved
// although this didnt work as planned so ill have to work further on this idea.
// >if (diff>range){
// >   xmoved.push(x*scaler);
// >   ymoved.push(y*scaler);
// >   diffmoved.push(diff);
// I added all moving points to their arrays if they passed the diff threshold
// and then I went through that array *with the intention of* only displaying the most moved points
// >compdiff = diffmoved[0];
// >compx = xmoved[0];
// >compy = ymoved[0];
// >for (v =1; v<=xmoved.length; v++){
// >   if(diffmoved[v]>compdiff){
// >      compdiff = diffmoved[v];
// >      compx = xmoved[v];
// >      compy = ymoved[v]; 
// >   }
// >   redDuck = new Duck(compx,compy);
// >   redDuck.show();
// >}
// That was the intention but it seems to get some randome points upon intitialisation and then does not add any further points, also its still adding points to the array so it takes forever.
// I need to take the most moved point within the inital (diff>range) if loop to avoid unnecessary work for the sketch.
// #### why didnt this work?: ####
// because im taking several ducks within the loop and repoalcinging them over and over...
// > I need to have a list of ducks (external to the draw function) that i append to each time the draw function detects movement.
// > upon each iteration i will find the most moves pixel, storing the greatest value in comx,compy,compdiff. 
// > AFTER i have looked through all the pixels and then i add them to the xmoved,ymoved and diff moves arrays.
// > important to assign compdiff to equal 0 in early draw function, needs to be redefined every iteration!
// > ALSO i made the choice to only multiply the x and y values by the scaler required for them to be displayed at the correct screen location until they are drawn as ducks, this saves extra caluclations that dont really matter for this use but it was a consideration made...
// ### now that it works with 1 duck! ###
// what if i make it work with teh 5 most moved ducks?

var video;
var scaler = 20; // how pixelated is the screen Very(20) - impossibly detailed (1); 
var duckScaler = 20;
var preFrame;
var range = 100; // range for motion detection
let xmoved = [0];
let ymoved = [0];
let diffmoved = [0];
let compdiff;
let compx;
let compy;
var duckcount = 5;

class Duck {
  constructor(x,y){
    // duck pos x and y
    this.x = x;
    this.y = y;
    // duck movement gradient
    this.t = random(0,10);
    this.u = random(0,10);
    // ducks rgb colour variables
    this.r = random(255);
    this.g = random(255);
    this.b = random(255);
    this.l = duckScaler;// unit length to standardise the size of the ducks
    this.grows = 1; //operator to control zoom fucntion
    this.z = random(width/6); //zoom variable for duck zoom rate
  }
  show(){
    // body
    stroke(this.r,this.g,this.b);
    fill(this.r,this.g,this.b);
    circle(this.x,this.y,this.l);
    circle(this.x+(4.5*this.l/5),this.y+(4*this.l/5),this.l);
    ellipse(this.x+(2*this.l/5),this.y+this.l,this.l*2,this.l+(this.l/5));
    //bill
    stroke(this.g, this.b, abs(this.r+100));
    fill(this.g, this.b, abs(this.r+100));
    ellipse(this.x-(2*this.l/5),this.y,(3*this.l/5),this.l/5);
    ellipse(this.x-(1.5*this.l/5),this.y-(this.l/10),(1.5*this.l/5),this.l/10);
    // duck eyes
      //eye white
    stroke(0,0,0);
    fill(0,0,0);
    circle(this.x+(this.l/5),this.y-(this.l/10),(1.1*this.l/5));
      // eye black
    stroke(255,255,255);
    fill(255,255,255);
    circle(this.x+(1.2*this.l/5),this.y-(1*this.l/5),this.l/10);
  }
  move(){
    // movement conditions duck 1
    this.x += this.t;
    if (this.x > width || this.x < 0){
      this.t = this.t * -1;
    }
    this.y += this.u;
    if ((this.y > height || this.y < 0)){ 
      this.u = this.u * -1;
    }
   }
  colour(r,g,b){
    // let pixelColour = webcam.get(this.x,this.y);
    // this.r = pixelColour[0];
    // this.g = pixelColour[1];
    // this.b = pixelColour[2];
    this.r = r;
    this.g = g;
    this.b = b;
  }
  size(g){
    this.l = g;
  }
  zoom(a,b, increment = 1){ 
    // start size (a) must be smaller than stop size (b)
    if (this.grows == 1){
      if (this.l < b){
        this.l += increment;     
      }  
    } 
    if (this.grows == -1) {
      if (this.l > a){
        this.l += -increment;  
      }
    }
    if (this.l >= b || this.l <= a){
      this.grows = this.grows * -1;
    }
  }
  animate(){
    this.move();
    this.colour();
    this.zoom(this.z,this.z+random(10));
    this.show();
  }
}

function setup() {
  createCanvas(640, 480);
  pixelDensity(1);
  capture = createCapture(VIDEO);//for better definition for interactions
  capture.hide(); // hide it
  video = createCapture(VIDEO);
  video.size(width / scaler, height / scaler);
  video.hide();
  preFrame = createImage(video.width, video.height);
  let redDuck = Duck;
}

function draw() {
  //background(255);
  translate(width,0); scale(-1,1); //flip the camera to be less confusing https://editor.p5js.org/js6450/sketches/ls5ETAfd0
  image(capture, 0, 0); // show the live camera
  video.loadPixels();
  preFrame.loadPixels();// NEW from https://editor.p5js.org/bestesaylar/sketches/WFsPqG-8A
  compdiff = 0; 
  for (let y = 0; y < video.height; y++) {
    for (let x = 0; x < video.width; x++) {
      var index = (x + y*video.width)*4;
      // ###################################################################################################### bestesaylar codelet pr = preFrame.pixels[index + 0];
      let pr = preFrame.pixels[index + 0];
      let pg = preFrame.pixels[index + 1];
      let pb = preFrame.pixels[index + 2];
      // let pbright = (pr + pg + pb) / 3; // makes a greyscale image

      let r = video.pixels[index + 0];
      let g = video.pixels[index + 1];
      let b = video.pixels[index + 2];
      // let bright = (r + g + b) / 3; // makes a greyscale image
			
      var diff = dist(r, g, b, pr, pg, pb); // https://p5js.org/reference/p5/dist/ dist achiebes what i was jankilly writing boolean statements for
			// if (diff<range){ // if diference is within range
      //   fill(r,g,b);
      // }
      if (diff>range){
        redDuck = new Duck(x*scaler,y*scaler);
        redDuck.show();
        // fill(255, 0, 0); // for some reason if this is ontop of the call to redDuck the red becomes white.. weird... because of teh eye whites being last in the showduck constructor call...
        if (diff > compdiff){
          // > upon each iteration i will find the most moved pixel, 
          // storing the greatest value in comx,compy,compdiff. 
          compdiff = diff;
          compx = x;
          compy = y;
          // until ive looked through all the pixels and then i add them to the xmoved,ymoved and diff moves arrays.
        }
      }
      // noStroke();
      // rect(x * scaler, y * scaler, scaler, scaler);
    }
  }
  // AFTER ive looked through all the pixels and then i add to the xmoved,ymoved and diff moves arrays.
  xmoved.push(compx);
  ymoved.push(compy);
  diffmoved.push(compdiff);
  preFrame.copy(video, 0, 0, video.width, video.height, 0, 0, video.width, video.height);// takes the current capture and loads it into preFarme for next iteration
  // now that i have assigned the positions of most moved positions i can draw the ducks
  for (let idx = 0; idx < xmoved.length; idx++){
    redDuck = new Duck(xmoved[idx]*scaler,ymoved[idx]*scaler);
    redDuck.show();
  }
  translate(width,0); scale(-1,1); //flip the camera to be less confusing https://editor.p5js.org/js6450/sketches/ls5ETAfd0
  text(xmoved,20,20)
  
}



